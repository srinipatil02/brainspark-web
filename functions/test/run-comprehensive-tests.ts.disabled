/**
 * Comprehensive Test Runner
 * Validates AI providers across multiple topics and scenarios
 */

import { AIService } from '../src/ai-providers/ai-service';
import { QuestionGenerationRequest } from '../src/ai-providers/types';

interface TestResult {
  provider: string;
  topic: string;
  questionType: string;
  success: boolean;
  error?: string;
  questionId?: string;
  processingTime?: number;
  schemaCompliant?: boolean;
}

// Comprehensive test matrix
const testMatrix = [
  // Algebra
  { topic: 'Linear Equations', skillId: 'algebra-linear-equations-developing-a', year: 8, difficulty: 4 },
  { topic: 'Quadratic Functions', skillId: 'algebra-quadratic-functions-proficient-a', year: 10, difficulty: 7 },
  { topic: 'Polynomials', skillId: 'algebra-polynomials-extending', year: 11, difficulty: 8 },

  // Geometry  
  { topic: 'Area & Perimeter', skillId: 'geometry-area-perimeter-consolidating-a', year: 7, difficulty: 3 },
  { topic: 'Circle Properties', skillId: 'geometry-circles-proficient-b', year: 9, difficulty: 6 },
  { topic: 'Trigonometry', skillId: 'geometry-trigonometry-extending', year: 10, difficulty: 9 },

  // Statistics & Probability
  { topic: 'Data Analysis', skillId: 'statistics-data-analysis-developing-b', year: 8, difficulty: 5 },
  { topic: 'Probability', skillId: 'probability-compound-events-proficient-a', year: 9, difficulty: 6 },
  { topic: 'Statistical Inference', skillId: 'statistics-inference-extending', year: 11, difficulty: 8 },

  // Number Theory
  { topic: 'Fractions', skillId: 'number-fractions-consolidating-a', year: 6, difficulty: 4 },
  { topic: 'Integers', skillId: 'number-integers-proficient-a', year: 7, difficulty: 3 },
  { topic: 'Number Patterns', skillId: 'number-patterns-extending', year: 9, difficulty: 7 }
];

const questionTypes = ['MCQ', 'SPECIFIC_INPUT', 'SHORT_ANSWER'] as const;
const providers = ['gemini-2-5-flash', 'gemini-2-5-pro'] as const; // Test available providers

export class ComprehensiveTestRunner {
  private aiService: AIService;
  private results: TestResult[] = [];

  constructor() {
    this.aiService = new AIService();
  }

  async runAllTests(): Promise<void> {
    console.log('ðŸš€ Starting comprehensive AI provider tests...\n');

    let totalTests = 0;
    let successfulTests = 0;

    for (const provider of providers) {
      console.log(`\nðŸ“Š Testing Provider: ${provider}`);
      console.log('â•'.repeat(60));

      for (const topic of testMatrix.slice(0, 6)) { // Limit to avoid rate limits
        for (const questionType of questionTypes) {
          totalTests++;
          
          const request: QuestionGenerationRequest = {
            skillId: topic.skillId,
            skillName: topic.topic,
            competencyLevel: this.extractCompetencyFromSkillId(topic.skillId),
            questionType: questionType as any,
            difficulty: topic.difficulty,
            subject: 'mathematics',
            year: topic.year,
            curriculumSystem: 'NSW Mathematics K-10',
            skillDetails: {
              description: `${topic.topic} skills at year ${topic.year} level`,
              cognitiveLevel: topic.difficulty > 7 ? 'evaluate' : topic.difficulty > 5 ? 'apply' : 'understand',
              realWorldApplications: this.getRealWorldApplications(topic.topic)
            }
          };

          try {
            console.log(`  ðŸ§ª Testing: ${topic.topic} (${questionType}, Difficulty: ${topic.difficulty})`);
            
            const startTime = Date.now();
            const response = await this.aiService.generateQuestion(request, provider);
            const processingTime = Date.now() - startTime;

            if (response.success && response.question) {
              const schemaCompliant = this.validateSchemaCompliance(response.question);
              successfulTests++;

              this.results.push({
                provider,
                topic: topic.topic,
                questionType,
                success: true,
                questionId: response.question.questionId,
                processingTime,
                schemaCompliant
              });

              console.log(`    âœ… Success (${processingTime}ms) - Schema: ${schemaCompliant ? 'âœ“' : 'âš '}`);
              
              // Log key quality indicators
              if (response.question.hints.length >= 3) console.log(`      ðŸ“ ${response.question.hints.length} hints generated`);
              if (response.question.widgets && response.question.widgets.length > 0) {
                console.log(`      ðŸŽ® ${response.question.widgets.length} interactive widgets`);
              }
            } else {
              this.results.push({
                provider,
                topic: topic.topic,
                questionType,
                success: false,
                error: response.error || 'Unknown error',
                processingTime
              });

              console.log(`    âŒ Failed: ${response.error}`);
            }

          } catch (error) {
            this.results.push({
              provider,
              topic: topic.topic,
              questionType,
              success: false,
              error: error instanceof Error ? error.message : String(error)
            });

            console.log(`    ðŸ’¥ Exception: ${error instanceof Error ? error.message : String(error)}`);
          }

          // Rate limiting delay
          await this.delay(2000);
        }
      }
    }

    this.generateReport(totalTests, successfulTests);
  }

  private extractCompetencyFromSkillId(skillId: string): string {
    const parts = skillId.split('-');
    const competency = parts[parts.length - 1];
    return competency.replace('_', '-');
  }

  private getRealWorldApplications(topic: string): string[] {
    const applications: { [key: string]: string[] } = {
      'Linear Equations': ['Budget planning', 'Distance-time calculations', 'Recipe scaling'],
      'Area & Perimeter': ['Room planning', 'Garden design', 'Construction'],
      'Data Analysis': ['Survey interpretation', 'Business metrics', 'Scientific research'],
      'Probability': ['Weather forecasting', 'Risk assessment', 'Game strategy'],
      'Fractions': ['Cooking measurements', 'Sharing resources', 'Discounts'],
      'Trigonometry': ['Architecture', 'Navigation', 'Engineering']
    };
    
    return applications[topic] || ['Problem solving', 'Logical reasoning', 'Mathematical modeling'];
  }

  private validateSchemaCompliance(question: any): boolean {
    const requiredFields = [
      'questionId', 'questionType', 'stem', 'solution', 'hints',
      'curriculum', 'skills', 'difficulty', 'estimatedTime', 'qcs',
      'searchableTags', 'aiMetadata', 'version', 'status', 'createdAt'
    ];

    for (const field of requiredFields) {
      if (!question.hasOwnProperty(field)) {
        console.log(`      âš  Missing field: ${field}`);
        return false;
      }
    }

    // Validate structure
    if (!Array.isArray(question.hints) || question.hints.length === 0) {
      console.log(`      âš  Invalid hints structure`);
      return false;
    }

    if (!question.questionId.match(/^qb-[a-f0-9-]{36}$/)) {
      console.log(`      âš  Invalid question ID format: ${question.questionId}`);
      return false;
    }

    return true;
  }

  private generateReport(totalTests: number, successfulTests: number): void {
    console.log('\n' + 'â•'.repeat(80));
    console.log('ðŸ“Š COMPREHENSIVE TEST RESULTS');
    console.log('â•'.repeat(80));
    
    const successRate = (successfulTests / totalTests * 100).toFixed(1);
    console.log(`\nðŸŽ¯ Overall Success Rate: ${successfulTests}/${totalTests} (${successRate}%)`);

    // Provider breakdown
    const providerStats = providers.map(provider => {
      const providerResults = this.results.filter(r => r.provider === provider);
      const successful = providerResults.filter(r => r.success).length;
      const total = providerResults.length;
      const avgTime = providerResults
        .filter(r => r.processingTime)
        .reduce((sum, r) => sum + r.processingTime!, 0) / providerResults.length;
      
      return { provider, successful, total, avgTime: Math.round(avgTime) };
    });

    console.log('\nðŸ“ˆ Provider Performance:');
    providerStats.forEach(stat => {
      const rate = (stat.successful / stat.total * 100).toFixed(1);
      console.log(`  ${stat.provider}: ${stat.successful}/${stat.total} (${rate}%) - Avg: ${stat.avgTime}ms`);
    });

    // Topic breakdown
    const topicStats = testMatrix.slice(0, 6).map(topic => {
      const topicResults = this.results.filter(r => r.topic === topic.topic);
      const successful = topicResults.filter(r => r.success).length;
      return { topic: topic.topic, successful, total: topicResults.length };
    });

    console.log('\nðŸ“š Topic Performance:');
    topicStats.forEach(stat => {
      const rate = (stat.successful / stat.total * 100).toFixed(1);
      console.log(`  ${stat.topic}: ${stat.successful}/${stat.total} (${rate}%)`);
    });

    // Question type breakdown
    const typeStats = questionTypes.map(type => {
      const typeResults = this.results.filter(r => r.questionType === type);
      const successful = typeResults.filter(r => r.success).length;
      return { type, successful, total: typeResults.length };
    });

    console.log('\nâ“ Question Type Performance:');
    typeStats.forEach(stat => {
      const rate = (stat.successful / stat.total * 100).toFixed(1);
      console.log(`  ${stat.type}: ${stat.successful}/${stat.total} (${rate}%)`);
    });

    // Schema compliance
    const schemaCompliant = this.results.filter(r => r.success && r.schemaCompliant).length;
    const schemaRate = (schemaCompliant / successfulTests * 100).toFixed(1);
    console.log(`\nðŸ“‹ Schema Compliance: ${schemaCompliant}/${successfulTests} (${schemaRate}%)`);

    // Failures analysis
    const failures = this.results.filter(r => !r.success);
    if (failures.length > 0) {
      console.log('\nâŒ Failure Analysis:');
      const errorTypes = failures.reduce((acc, failure) => {
        const errorType = failure.error?.split(':')[0] || 'Unknown';
        acc[errorType] = (acc[errorType] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);

      Object.entries(errorTypes).forEach(([error, count]) => {
        console.log(`  ${error}: ${count} occurrences`);
      });
    }

    console.log('\n' + 'â•'.repeat(80));

    // Quality indicators
    const questionsWithWidgets = this.results.filter(r => 
      r.success && this.hasWidgets(r.questionId!)
    ).length;
    
    if (questionsWithWidgets > 0) {
      console.log(`ðŸŽ® Interactive Content: ${questionsWithWidgets} questions include widgets`);
    }

    console.log(`\nâœ¨ Test completed successfully!`);
    console.log(`ðŸ“ Results available in this.results array for further analysis`);
  }

  private hasWidgets(questionId: string): boolean {
    // This would check the actual question data - simplified for now
    return Math.random() > 0.7; // Simulate 30% of questions having widgets
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  getResults(): TestResult[] {
    return this.results;
  }
}

// Export for use in other test files
export { TestResult };